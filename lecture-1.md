# Lecture 1: 基础

说明：

- 假设您已经具有基本的计算机知识
- 不作为就业培训材料或者面试指南



Java源于Sun Microsystems公司的James Gosling博士于1991年发明的一个名叫Oak的编程语言，当时主要想用在消费电子产品（比如机顶盒之类）上，但是没成气候。到了1995年，互联网在美国开始风起云涌，Sun捕捉到这个机会，就将Oak改名叫Java，在SunWorld大会上，发布了Java 1.0，口号是：Write Once, Run Anywhere。这个事件标志着Java正式诞生，20多年过去了，Java和JVM演变成一个庞大的软件开发平台和生态系统，在企业应用和互联网领域大放异彩。

我们知道，计算机有不同的硬件结构，不同的操作系统。那么，运行在其上的软件，肯定会有一些差异，这叫作“不兼容”。软件的兼容性分为两个层面：

- 源代码兼容

  如果您在编程的时候，只用了语言本身提供的机制以及标准库，那么编写出来的源代码，与更下一层的操作系统无关。这个源代码是可以被移植到其它系统上而不用修改的（或者很少量的修改），编译器知道怎么产生相应平台的目标代码。

- 二进制兼容

  如果源代码被编译成二进制之后的可执行文件（或者库），也能在不同平台上运行，这就是二进制层面的兼容了。这通常只能在同一种操作系统上才能做到，比如一个软件可以在Windows XP上运行，也能在Windows 10上运行；或者一个.so的动态链接库可以适用于多种Linux发行版。

当然，软件开发层面，还有API级别的兼容。这个跟我们要讲的东西，暂时无关，以后再细说。

所以您看，二进制兼容基本上做不到，源代码兼容也很麻烦（尤其是代码里用到了平台特定的API）。那么“Write Once, Run Anywhere”对开发者而言，就成了一个非常吸引人的特性。要实现这个目标，就得引入一个新的概念：虚拟机（Virtual Machine, VM。Java虚拟机被叫作JVM）。虚拟机的作用是，屏蔽不同的硬件架构和操作系统的差异，对软件开发者提供一个一致的开发模型和运行时环境。总而言之，Java就是一个基于虚拟机的编程语言，Java源代码被编译成一种叫做字节码（Byte Code）的中间结果，运行时再由虚拟机翻译成不同的目标机器的机器码执行。我们先建立这么一个初步的认识，以便能够继续学习后续内容，最后一讲，我们将专门来讨论JVM。

几个常被提及的概念，和Java纷繁复杂的版本规则，也有必要专门解释一下：

- **Java** 狭义上讲，它是一种程序设计语言；广义上讲，它现在代表了以Java语言和JVM虚拟机为基础的一个软件开发平台。
- **JVM** Java虚拟机。Java的核心，早期只能支持Java语言，现在已经可以支持很多种语言比如Scala, JRuby， JPython等。
- **JDK** Java Development Kit。Java的开发、运行环境，包含了编译器、运行时、标准库等基础设施。
- **JRE** Java Runtime Environment。Java运行时环境，去掉了一些开发工具和组件，体积小于JDK，通常用于软件发布。Java 11开始，不再提供单的JRE，直接安装JDK即可。
- **JCP** Java Community Process, 一个负责维护Java规范和标准化的国际组织，IBM, ORACLE, GOOGLE这些大企业都是其成员。
- **JSR** Java Specification Requests, Java规范提案。 如果要增加某一个新功能，就需要先提一个JSR，然后经过JCP的审议批准，体现在未来某个Java版本中。

历史上，根据不同的功能/用途（或市场定位），Java被划分为三个版本：J2ME, J2SE和J2EE。J2表示Java 2 Platform，而Java最新的版本已经到了18了，所以改称为Java ME（Mobile Edition）, Java SE（Standard Edition）, Java EE（Enterprise Edition）。SE包含了Java的所有核心功能，而EE只是一些JSR，一般由厂商来实现。比如Servlet，分布式事务（XA）等。

JavaSE采用数字来命名版本。早期用1.x表示，比如1.5（就是大名鼎鼎的Java 2），1.8（也被称作Java 8）。1.8之后就直接改为Java 9, Java 10......这种方式了，目前最新版本是18。除了一些历史遗留的代码/系统还运行在Java 8上之外，现在基本上都使用Java 11了，这是一个Long-Term-Support(LTS)版本，稳定可靠，可以在生产环境长期使用。前些时候，Java之父James Gosling博士推荐开发者尽快升级到Java 17（继11之后的另一个LTS版本），以便享受现代Java带来的性能、安全和开发效率的提升。

## 1.1 类型系统

计算机的程序设计语言(Programming Language, PL)跟我们人类交流、写作用的自然语言的作用类似，只不过交流的双方，一方是软件开发者，另一方是计算机。机器是一个很死板的、不会变通的东西，只会作确定的事情（这个讲义里不讨论AI），所以程序设计语言要比自然语言更为抽象和严谨，比如机器就不懂得去猜测双关语的意思。类型系统就是一个抽象的模型，用来描述现实世界里纷繁复杂的事物。

程序设计语言的类型，大致有两种思路：静态类型（强类型）和动态类型（弱类型）。所谓静态类型就是，任何变量，在编译期都必须明确地、显示地指定一个类型，在指定之后就不可更改了。C，C++, C#, Java包括现在流行的Rust都是静态类型的语言：

```
int i = 1；
float f = 2.0f;
let age : u8 = 32;
```

不同的语言，定义的语法有差别，但核心是一样的，都必须指定类型（ int, float, u8 这样的东西）。与之相反的是，弱类型的动态语言，不需要显示指定变量的数据类型，在运行时，编译器、虚拟机会去推断变量到底应该是个什么类型，最为典型的就是JavaScript和Python这两种语言：

```
let age = 32
var name = "John Denver";
address = '北京市海淀区上地七街'
```

弱类型的语言通常被称作动态语言或脚本语言，它的运行方式是由虚拟机逐行解释执行的，不需要由程序员手工编译成平台目标代码或者字节码(Byte Code)或者翻译为中间语言(IL)。它的优点是，编程相对自由一些，同一个变量，上面存放的是整数，隔几行代码，又用来存放字符串了。当然随之带来的麻烦就是更容易出错，尤其是在代码量较大的项目里。

我们也不一定要在静态或者动态类型的语言里分个优劣。风水是轮流转的，早些年的语言都是静态类型的，大家就觉得动态类型推断的很酷，所以就涌现了很多动态类型的语言，甚至静态语言也从语法层面可以模拟一下：

```
//Java or C#
var i = 32;
```

这看起来跟JavaScript颇为相像了，但它只是一个语法糖（Syntactic Sugar），类型推断是在编译时进行的，和运行时类型推断有本质区别。

当弱类型语言盛极一时的时候，大家又开始反思它的缺点，尤其是带来的软件工程方面的问题，设计出了像Rust这样的静态语言，用极度严格的类型检查来避免不必要的错误，降低软件开发和维护的成本，提升安全性。

但是，不管是静态还是动态类型的语言，或者说，不论是否要求程序员显示地声明变量类型，一个变量它都应该属于某个类型才对。我们把目光聚焦到Java的类型系统上来，考察它如何用有限的类型描述无穷的世界。

### 1.1.1 基本类型

在Java中，类型被分为基本类型（Primitive Types）和引用类型（Reference Types）。基本类型有时候也称之为内置类型（Built-in Types），包括了数值类型、布尔类型和字符（通常也被认为是数值的一种）几种，参见下表：

| #    | 类型名  | 中文名       | 说明                                                         |
| ---- | ------- | ------------ | ------------------------------------------------------------ |
| 1    | byte    | 字节         | 8 bits，表示-128 - 127之间的整数                             |
| 2    | short   | 短整型       | 2 bytes，表示 -32768 - 32767之间的整数                       |
| 3    | int     | 整型         | 4 bytes，表示的范围在正负20多亿之间                          |
| 4    | long    | 长整型       | 8 bytes，绝大多数情况下，它的表示范围都够用了                |
| 5    | float   | 单精度浮点数 | 4 bytes，遵循IEEE-754标准                                    |
| 6    | double  | 双精度浮点数 | 8 bytes，IEEE-754标准,范围和精度都比float大                  |
| 7    | boolean | 布尔型       | true \|false，表达一种二值状态，黑/白，是/否，有/无，开/关，死/活... |
| 8    | char    | 字符         | 可以表示UNICODE字符集中从'\u0000' - ''\uffff'之间的字符，范围相当于 unsigned short |

我们发现，基本类型都跟数值有关系，这有两种可能：

1. 这个世界上的纷繁复杂的关系，多数都可以抽象成数量关系来描述；
2. 计算机擅长作数字运算，因此就想办法把别的关系转化为数量关系来表达。

不管以上哪一种可能成立，都不影响一个事实：所有的程序设计语言，基本类型都差不多是这个样子。

### 1.1.2 引用类型

为了增强表达能力，在基本类型之外扩展出了一些复合的类型，Java里面，称之为引用类型。理解引用（Reference）的概念，需要一些Java内存模型的知识，我们先略过。简而言之，一个变量如果是引用类型，这个变量存储的并不是这个数据本身，而是它在另外一块内存上的地址。Java中，引用类型有四种：

| #    | 类型      | 中文名   | 说明                                                         |
| ---- | --------- | -------- | ------------------------------------------------------------ |
| 1    | class     | 类       | 类是一种复合数据类型，是实现OOP的核心机制，将一组数据和行为封装在一起，作为整体 |
| 2    | interface | 接口     | 类的一种特殊形式，是一种抽象手段。它只包含行为声明(和缺省实现)，以及静态的数据 |
| 3    | type      | 类型变量 | 常用于泛型。比如：<T extends User>，这个T就是类型变量        |
| 4    | array     | 数组     | 多个元素组成的集合，通过下标来访问集合中的元素。元素可以是基本类型、也可以是引用类型 |

class和interface的内容较多，我们将专门用一小节来讲述。type variables留在泛型部分展开讲。

在Java中，有的数据结构只适用于引用类型，比如List, Map等。因此，语言提供了一种内置的机制，将基本类型转换为一个引用类型（这个过程叫做装箱，Boxing）或者将引用类型退化成一个基本类型（这个过程叫拆箱，Unboxing）。装箱和拆箱的过程是全自动的，只是有两个问题需要注意：

1. 大量的、频繁的装箱拆箱会带来一定的性能开销，应尽量避免；

2. 装箱以后，就可能出现null pointer的问题，使用时需要注意。比如下面的代码：

   ```
   public int add(Integer arg0, Integer arg1){
   	Integer result = arg0 + arg1; //此处不考虑溢范围出问题
   	return result; //此处自动拆箱为基本类型int
   }
   
   var result = add(1, 2); //参数1，2将被装箱成两个Integer类型的对象传入，add方法工作正常
   var result = add(null, null); //传入两个null，作为参数，也是合法的。但是在add函数内会引发异常
   ```

   基本类型和它的引用类型之间的对应关系如下表：

| #    | 基本类型 | 引用类型（class） |
| ---- | -------- | ----------------- |
| 1    | byte     | Byte              |
| 2    | short    | Short             |
| 3    | int      | Integer           |
| 4    | long     | Long              |
| 5    | float    | Float             |
| 6    | double   | Double            |
| 7    | boolean  | Boolean           |

数组（Array）是一种集合（Collection）类型，它是一个容器，能盛放指定数量的元素。所有的元素的数据类型必须相同，可以是基本类型，也可以是应用类型。从数值计算的角度，我们可以将数组理解为一个向量（Vector），向量的维度（Dimension）必须大于或等于 1，即可以是一维的，也可以是高维的。二维的数组，就是一个矩阵。在使用的时候，通过下标（或者叫索引，Index）来访问。在绝大多数程序设计语言里，下标约定俗成从0开始，即array[0]表示第一个元素（特例：Fortran语言里，默认从1开始）。如果您发现某人在生活中计数喜欢从0开始，他可能是一个程序员。

```
int[] numbers = new int[4]; //定义一个长度为4的、元素类型为int的数组
for(int i = 0; i < numbers.length; i++){
	numbers[i] = i;	//循环为数组每一个元素赋值
}

//这是另一种定义并初始化数组的方法，不用指定长度，但给出集合中的每个元素
int[] numbers = new int[]{1, 2, 3, 4};

int length = numbers.length; //数组是个引用类型，它除了包含元素之外，还有一个属性length，表示元素的个数。
```

Java是一种严格的面向对象（Object Oriented，OO）语言，要求我们使用面向对象编程（Object Oriented Programming）范式。它的OO特性，在引用类型的层次设计上，体现得淋漓尽致。所有引用类型，都有一个共同的祖先，即：java.lang.Object。其它的都是派生自这个class，然后构成了一棵复杂的类型树，有兴趣的读者可以看看Java标准库的层次结构。OOP是一个非常重要的话题，我们将专门用一讲来讨论。

### 1.1.3 缺省值和初始化

当我们定义了一个某种数据类型的变量，还没有给它赋值的时候，它会自动获得一个缺省值。Java的缺省值规则很简单，遵循一下几条：

1. 基本类型中，整数（ byte, short, int, long）类型的缺省值是0。当然这个0会被解释为对应类型的0，也就是占用的内存长度不一样；
2. 基本类型中，浮点数（float, double）类型的缺省值为0.0。占用4个字节或8个字节的内存空间；
3. boolean型，缺省值是false；
4. 引用类型，缺省值都是null。null是一个特殊的值，表示它不指向任何的内存区域。null和blank, empty并不是一回事，需要注意。null这个东西值得多说几句，全世界的软件，可能半数以上的bug，都是因它而引发的。C/C++语言的空指针，Java里的NullPointerException，都是让人头疼，编程时需要仔细。为了最大可能地杜绝这个问题，IDE、语言机制、编译器，都做了很多工作。现在的IDE比人还聪明，比如Eclipse，对于未初始化的引用类型变量会给出提示；对可能出现null的代码也会提示。Java 8开始，也提供了一种叫做Optional的机制，帮助程序员简化null指针判断，避免null pointer exception。

理论上，定义一个任何类型的变量，在使用之前，都需要被初始化。这是一个良好的编程习惯，因为编译器给出的缺省值未必符合您的需要。基本类型和引用类型的初始化方法略微不同：

- 初始化基本类型

  ```
  //直接将值付给变量即可
  int a = 1;
  float f = 1.0;
  char ch = 'a';
  
  //编译期自动类型推断
  var d = 1d;
  var result = false;
  ```

- 初始化引用类型

  ```
  Object obj = new Object();
  User user = new User();
  int[] array = new int[s4];
  Map<Integer, String> map = new HashMap<>();
  ```

  从上面的代码可见，引用类型的初始化，必须用new关键字，它会为对象在堆上分配内存空间。Java虚拟机有一个垃圾回收器(Garbige Collector, GC)，当对象不再使用的时候，内存空间被自动释放。在C语言中，则需要手动调用free函数释，C++需要使用delete语句，释放空间。内存泄漏(Memory Leak)也是一种令人困扰万分而且非常难以定位的BUG，跟null pointer一样臭名昭著。近年来流行的Rust语言，采用了一些近似严酷的方法来解决一个问题：既不需要垃圾回收器也不需要手工管理内存。

  有一个使用特别频繁的引用类型，叫做String，它代表了内存中的一个以Unicode编码的字符序列，就是我们常常说的“字符串”。String的初始化，看起来有点不一样：

  ```
  //初始化String时，可以不用new关键字，直接把双引号包裹起来的字符串赋给变量即可
  String name = "John Denver";
  var mobile = "13989898989";
  
  //当然，您也可以用new。就是有点画蛇添足的感觉
  String university = new String("MIT");
  ```

  
